<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multiplayer Dodge</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; display: flex; justify-content: center; align-items: center; height: 100vh; }
        /* Hide default cursor when game is active */
        canvas { display: none; background: #222; cursor: none; }
        #uiOverlay { position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 5; padding: 15px; display: none; /* Hidden initially */ justify-content: space-between; align-items: flex-start; }
        #gameInfo { font-size: 20px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; }
        #scoreDisplay, #levelDisplay { margin-bottom: 5px; }
        #playerList { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; font-size: 14px; max-height: 200px; overflow-y: auto; pointer-events: all; }
        #playerList h3 { margin: 0 0 5px 0; font-size: 16px; text-align: center; }
        #playerList ul { list-style: none; padding: 0; margin: 0; }
        #playerList li { margin-bottom: 3px; }
        .dead-player { text-decoration: line-through; color: #aaa; }
        #respawnMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(200, 0, 0, 0.8); color: white; padding: 20px 30px; border-radius: 10px; font-size: 24px; text-align: center; z-index: 20; display: none; /* Initially hidden */ white-space: pre-wrap; /* Allow newlines */ }
        #customCursor { position: absolute; width: 10px; height: 10px; background: rgba(255, 255, 255, 0.7); border-radius: 50%; border: 1px solid white; pointer-events: none; /* Don't interfere with canvas events */ z-index: 100; transform: translate(-50%, -50%); /* Center on mouse */ display: none; /* Hidden initially */ }

        /* --- Username Input --- */
        #usernamePrompt { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.9); z-index: 10; text-align: center; padding: 20px; }
        #usernamePrompt h2 { font-size: 36px; margin-bottom: 20px; color: #eee; }
        #usernameInput { padding: 10px 15px; font-size: 20px; margin-bottom: 20px; width: 250px; text-align: center; border: 2px solid #555; background-color: #333; color: white; border-radius: 5px; }
        .menuButton { padding: 15px 30px; font-size: 24px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 8px; transition: background 0.3s, transform 0.1s; margin-top: 15px; box-shadow: 0 4px #999; min-width: 180px; }
        .menuButton:hover { background: #45a049; }
        .menuButton:active { background-color: #3e8e41; box-shadow: 0 2px #666; transform: translateY(3px); }
        #mouseToggleInfo { margin-top: 15px; color: #bbb; font-size: 14px;}
    </style>
</head>
<body>

    <div id="usernamePrompt">
        <h2>Enter Your Username</h2>
        <input type="text" id="usernameInput" placeholder="Username" maxlength="16">
        <button id="playBtn" class="menuButton">PLAY</button>
        <p id="mouseToggleInfo">
            (WASD/Arrows or Mouse to Move)<br/>
            Press 'M' in-game to toggle mouse control.
        </p>
         <div id="respawnMessage"></div> <!-- Message area for timeout -->
    </div>

    <div id="uiOverlay"> <!-- UI elements are shown/hidden by JS -->
        <div id="gameInfo">
            <div id="scoreDisplay">Score: 0</div>
            <div id="levelDisplay">Level: 1</div>
        </div>
        <div id="playerList">
            <h3>Players</h3>
            <ul id="players"></ul>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="customCursor"></div> <!-- Custom cursor element -->

<script>
(function() { // IIFE

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const uiOverlay = document.getElementById('uiOverlay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const playerListUl = document.getElementById('players');
    const usernamePrompt = document.getElementById('usernamePrompt');
    const usernameInput = document.getElementById('usernameInput');
    const playBtn = document.getElementById('playBtn');
    const respawnMessageDiv = document.getElementById('respawnMessage');
    const customCursor = document.getElementById('customCursor');

    let ws = null;
    let players = {}; // Local cache of player states
    let obstacles = []; // Local cache of obstacle states
    let myPlayerId = null;
    let currentLevel = 1;
    let currentScore = 0;
    let lastSentInputTime = 0;
    const inputSendInterval = 1000 / 45; // Send input frequently (~45 FPS)
    let inputIntervalId = null; // Store interval ID to clear later

    const keys = {}; // Track key state
    let clientMousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let useMouseControl = false; // Controlled by 'M' key
    let gameActive = false; // Flag to control rendering loop/input
    let animationFrameId = null; // Store requestAnimationFrame ID

    // --- Canvas Setup ---
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    // --- WebSocket Connection ---
    function connectWebSocket(username) {
        respawnMessageDiv.style.display = 'none'; // Clear previous message
        respawnMessageDiv.textContent = '';
        playBtn.disabled = true; // Prevent double clicks
        usernameInput.disabled = true;

        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.hostname}:${window.location.port || (wsProtocol === 'wss:' ? 443 : 80)}`;
        // const wsUrl = `ws://localhost:3000`; // Use for local testing

        console.log(`Attempting to connect to: ${wsUrl}`);
        ws = new WebSocket(wsUrl);
        gameActive = false; // Don't start rendering/input yet

        ws.onopen = () => {
            console.log('WebSocket connection established.');
            usernamePrompt.style.display = 'none';
            uiOverlay.style.display = 'flex';
            canvas.style.display = 'block';
            resizeCanvas(); // Ensure canvas size is correct after display change

            ws.send(JSON.stringify({ type: 'setUsername', username: username }));

            // Game loop started by receiving 'yourId' and initial state
        };

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);

                if (data.type === 'gameState') {
                    players = data.players || {};
                    obstacles = data.obstacles || [];
                    if (data.level !== currentLevel) currentLevel = data.level;
                    if (data.score !== currentScore) currentScore = data.score;
                    updateUI();
                } else if (data.type === 'yourId') {
                    myPlayerId = data.id;
                    currentLevel = data.currentLevel || 1;
                    currentScore = data.currentScore || 0;
                    console.log(`Received my Player ID: ${myPlayerId}`);

                    if (data.initialState) {
                        players = data.initialState.players || {};
                        obstacles = data.initialState.obstacles || [];
                        console.log("Applied initial game state from server.");
                    }
                    updateUI();

                    // Start sending input AFTER getting ID and initial state
                    if (!inputIntervalId) { // Prevent multiple intervals
                        inputIntervalId = setInterval(sendInput, inputSendInterval);
                    }
                    // Start rendering loop
                    if (!gameActive) {
                         gameActive = true;
                         requestAnimationFrame(gameLoop);
                         canvas.style.cursor = 'none'; // Hide default cursor when game starts
                         customCursor.style.display = 'block'; // Show custom cursor
                    }

                } else if (data.type === 'playerLeft') {
                     console.log(`Player ${data.id} left.`);
                     // Let next gameState update remove them visually
                 } else if (data.type === 'levelUp') {
                     console.log(`Server announced Level Up to ${data.newLevel}`);
                     currentLevel = data.newLevel;
                     updateUI();
                     // Optional: Add a visual "Level Up!" effect here
                 } else if (data.type === 'respawnTimeout') {
                    console.log(`Respawn timeout active: ${data.timeLeft}s left.`);
                    respawnMessageDiv.textContent = `You died recently!\nRespawn available in ${data.timeLeft} seconds.`;
                    respawnMessageDiv.style.display = 'block';
                    // Server will close the connection, cleanup in onclose
                    usernamePrompt.style.display = 'flex'; // Show prompt overlay again
                    uiOverlay.style.display = 'none';
                    canvas.style.display = 'none';
                    playBtn.disabled = false; // Re-enable button
                    usernameInput.disabled = false;
                }

            } catch (error) {
                console.error('Error processing message:', event.data, error);
            }
        };

        ws.onerror = (error) => {
            console.error('WebSocket Error:', error);
            if (!gameActive && !respawnMessageDiv.textContent) { // Only show alert if initial connect fails
                 alert('Connection error. Please check the server and refresh.');
            }
            shutdownClient();
        };

        ws.onclose = (event) => {
            console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
            // Don't show alert if server closed due to timeout message we displayed
            if (event.code !== 1008 || !respawnMessageDiv.textContent.includes('died recently')) {
                // alert('Connection closed.'); // Usually not needed
            }
            shutdownClient();
        };
    }

    function shutdownClient() {
         console.log("Shutting down client state...");
         gameActive = false;
         if (ws) {
             ws.onclose = null; // Prevent loop if close triggers shutdown again
             ws.onerror = null;
             ws.onmessage = null;
             ws.onopen = null;
             if(ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                ws.close();
             }
             ws = null;
         }
         if (inputIntervalId) {
             clearInterval(inputIntervalId);
             inputIntervalId = null;
         }
         if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
         }
         myPlayerId = null;
         players = {};
         obstacles = [];
         currentLevel = 1;
         currentScore = 0;
         keys = {}; // Reset keys
         useMouseControl = false; // Reset mouse toggle

         // Reset UI
         usernamePrompt.style.display = 'flex';
         uiOverlay.style.display = 'none';
         canvas.style.display = 'none';
         canvas.style.cursor = 'default'; // Restore default cursor
         customCursor.style.display = 'none'; // Hide custom cursor
         playBtn.disabled = false; // Re-enable button
         usernameInput.disabled = false;
         // Don't clear respawn message here, it's cleared on next connect attempt
         updateUI(); // Clear player list etc.
    }


    // --- Input Handling ---
    document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        keys[key] = true;
        // Toggle Mouse Control
        if (key === 'm' && gameActive) {
            useMouseControl = !useMouseControl;
            console.log("Mouse control toggled:", useMouseControl);
            // Immediately send updated state
            sendInput(true); // Force send immediate update
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!gameActive) return;
        const rect = canvas.getBoundingClientRect();
        clientMousePos.x = e.clientX - rect.left;
        clientMousePos.y = e.clientY - rect.top;
        // Update custom cursor position
        customCursor.style.left = `${e.clientX}px`;
        customCursor.style.top = `${e.clientY}px`;
    });

     canvas.addEventListener('mouseenter', () => {
         if(gameActive) customCursor.style.display = 'block';
     });
     canvas.addEventListener('mouseleave', () => {
        // Optional: Stop sending mouse? Keep cursor visible?
         if(gameActive) customCursor.style.display = 'none';
     });

     // Prevent context menu on canvas
     canvas.addEventListener('contextmenu', (e) => e.preventDefault());


    // --- Send Input to Server ---
    // Takes optional forceSend flag
    function sendInput(forceSend = false) {
        if (!ws || ws.readyState !== WebSocket.OPEN || myPlayerId === null || !gameActive) {
            return;
        }

        const now = Date.now();
        // Send immediately if forced (like on toggle), otherwise check interval
        if (!forceSend && now - lastSentInputTime < inputSendInterval * 0.9) {
             return; // Skip sending if too soon
        }

        const inputData = {
            type: 'input',
            useMouse: useMouseControl // Always send the current toggle state
        };

        if (useMouseControl) {
            inputData.mousePos = { x: clientMousePos.x, y: clientMousePos.y };
        } else {
             // Send only relevant keys
            const activeKeys = {};
            for (const key in keys) {
                if (keys[key]) activeKeys[key] = true;
            }
            inputData.keys = activeKeys;
        }

        try {
            ws.send(JSON.stringify(inputData));
            lastSentInputTime = now;
        } catch (error) {
            console.error("Error sending input:", error);
            // Consider closing connection if send fails repeatedly
        }
    }


    // --- Drawing Functions ---
    function drawPlayer(player) {
        if (!player) return; // Safety check

        ctx.save(); // Save context state

        ctx.lineWidth = 1; // Default line width

        if (!player.isAlive) {
            ctx.globalAlpha = 0.4; // Make dead players semi-transparent
            ctx.fillStyle = '#AAAAAA'; // Grey out dead players
            ctx.strokeStyle = 'black';
        } else {
             ctx.globalAlpha = 1.0;
             ctx.fillStyle = player.color || 'white';
             ctx.strokeStyle = 'black';
        }

        // Draw player circle
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size || 15, 0, Math.PI * 2);
        ctx.fill();

        // Add white outline if it's the local player
        if (player.id === myPlayerId) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
        }
        ctx.stroke();


        // Draw username
        ctx.fillStyle = player.isAlive ? 'white' : '#ddd';
        ctx.font = '12px Segoe UI';
        ctx.textAlign = 'center';
        // Prevent username drawing if player object is incomplete
        if (typeof player.x === 'number' && typeof player.y === 'number') {
             ctx.fillText(player.username || `Player ${player.id}`, player.x, player.y - (player.size || 15) - 5);
        }

        ctx.restore(); // Restore context state (includes alpha, fillStyle, textAlign, etc.)
    }

    function drawObstacle(obstacle) {
         if (!obstacle) return; // Safety check
         ctx.fillStyle = obstacle.color || '#ff4444';
         ctx.beginPath();
         // Ensure size is valid before drawing
         const radius = (obstacle.size || OBSTACLE_BASE_SIZE) / 2;
         if (typeof obstacle.x === 'number' && typeof obstacle.y === 'number' && radius > 0) {
            ctx.arc(obstacle.x, obstacle.y, radius, 0, Math.PI * 2);
            ctx.fill();
         }
    }

    // --- Update UI ---
    function updateUI() {
        if (scoreDisplay) scoreDisplay.textContent = `Score: ${currentScore}`;
        if (levelDisplay) levelDisplay.textContent = `Level: ${currentLevel}`;
        updatePlayerList();
    }

    function updatePlayerList() {
         if (!playerListUl) return;
         playerListUl.innerHTML = ''; // Clear existing list
         Object.values(players).forEach(player => {
              if (!player) return; // Skip if player data is missing somehow
             const li = document.createElement('li');
             li.style.color = player.color || 'white';
             li.textContent = player.username || `Player ${player.id}`;
             if (!player.isAlive) {
                 li.classList.add('dead-player');
             }
             if (player.id === myPlayerId) {
                 li.textContent += ' (You)';
                 li.style.fontWeight = 'bold';
             }
             playerListUl.appendChild(li);
         });
     }


    // --- Game Loop (Client-side Rendering) ---
    function gameLoop(timestamp) {
        if (!gameActive) {
             console.log("Game not active, stopping render loop.");
             animationFrameId = null; // Ensure we don't store stale ID
             return; // Stop loop if connection closes or game ends
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw obstacles FIRST (behind players)
        obstacles.forEach(drawObstacle);

        // Draw players
        Object.values(players).forEach(drawPlayer);

        // Request next frame
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Initialization ---
     playBtn.addEventListener('click', () => {
         const username = usernameInput.value.trim();
         if (username) {
             connectWebSocket(username);
         } else {
             // Use a default if blank
             connectWebSocket(`Player${Math.floor(Math.random()*1000)}`);
         }
     });

     // Allow Enter key in username input
     usernameInput.addEventListener('keypress', (e) => {
         if (e.key === 'Enter') {
             playBtn.click(); // Trigger the button click
         }
     });

    // Initial UI state setup
    resizeCanvas(); // Size canvas correctly first
    shutdownClient(); // Set initial UI state (prompt visible, game hidden)
    usernameInput.focus();

})(); // End IIFE
</script>
</body>
</html>
