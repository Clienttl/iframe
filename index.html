<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multiplayer Dodge</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; background: #222; cursor: crosshair; } /* Hide cursor on canvas, show crosshair */
        #uiOverlay { position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 5; padding: 15px; display: flex; justify-content: space-between; align-items: flex-start; }
        #gameInfo { font-size: 20px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; }
        #scoreDisplay, #levelDisplay { margin-bottom: 5px; }
        #playerList { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; font-size: 14px; max-height: 200px; overflow-y: auto; pointer-events: all; }
        #playerList h3 { margin: 0 0 5px 0; font-size: 16px; text-align: center; }
        #playerList ul { list-style: none; padding: 0; margin: 0; }
        #playerList li { margin-bottom: 3px; }
        .dead-player { text-decoration: line-through; color: #aaa; }

        /* --- Username Input --- */
        #usernamePrompt { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; /* Initially hidden */ flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.9); z-index: 10; text-align: center; padding: 20px; }
        #usernamePrompt h2 { font-size: 36px; margin-bottom: 20px; color: #eee; }
        #usernameInput { padding: 10px 15px; font-size: 20px; margin-bottom: 20px; width: 250px; text-align: center; border: 2px solid #555; background-color: #333; color: white; border-radius: 5px; }
        .menuButton { padding: 15px 30px; font-size: 24px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 8px; transition: background 0.3s, transform 0.1s; margin-top: 15px; box-shadow: 0 4px #999; min-width: 180px; }
        .menuButton:hover { background: #45a049; }
        .menuButton:active { background-color: #3e8e41; box-shadow: 0 2px #666; transform: translateY(3px); }
    </style>
</head>
<body>

    <div id="usernamePrompt">
        <h2>Enter Your Username</h2>
        <input type="text" id="usernameInput" placeholder="Username" maxlength="16">
        <button id="playBtn" class="menuButton">PLAY</button>
        <p style="margin-top: 20px; color: #aaa; font-size: 14px;">(WASD/Arrows or Mouse to Move)</p>
    </div>

    <div id="uiOverlay" style="display: none;"> <!-- Hidden initially -->
        <div id="gameInfo">
            <div id="scoreDisplay">Score: 0</div>
            <div id="levelDisplay">Level: 1</div>
        </div>
        <div id="playerList">
            <h3>Players</h3>
            <ul id="players">
                <!-- Player list generated by JS -->
            </ul>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
(function() { // IIFE

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const uiOverlay = document.getElementById('uiOverlay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const playerListUl = document.getElementById('players');
    const usernamePrompt = document.getElementById('usernamePrompt');
    const usernameInput = document.getElementById('usernameInput');
    const playBtn = document.getElementById('playBtn');

    let ws = null;
    let players = {}; // Local cache of player states
    let obstacles = []; // Local cache of obstacle states
    let myPlayerId = null;
    let currentLevel = 1;
    let currentScore = 0;
    let lastSentInputTime = 0;
    const inputSendInterval = 1000 / 30; // Send input ~30 times/sec max

    const keys = {}; // Track key state
    let mousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let isMouseActive = false; // Track if mouse was the last input source

    // --- Canvas Setup ---
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); // Initial size

    // --- WebSocket Connection ---
    function connectWebSocket(username) {
        // Determine WebSocket protocol based on HTTP protocol
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // Construct WebSocket URL (replace window.location.hostname if server is elsewhere)
        const wsUrl = `${wsProtocol}//${window.location.hostname}:${window.location.port || (wsProtocol === 'wss:' ? 443 : 80)}`;
        // Note: For local testing, if server is on 3000, you might need:
        // const wsUrl = `ws://localhost:3000`; // Or your specific server address/port

        console.log(`Attempting to connect to: ${wsUrl}`);
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            console.log('WebSocket connection established.');
            // Hide username prompt, show game UI
            usernamePrompt.style.display = 'none';
            uiOverlay.style.display = 'flex';
            canvas.style.display = 'block'; // Ensure canvas is visible

            // Send username
            ws.send(JSON.stringify({ type: 'setUsername', username: username }));

            // Start game loop
            requestAnimationFrame(gameLoop);
            // Start sending input periodically
            setInterval(sendInput, inputSendInterval);
        };

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);

                if (data.type === 'gameState') {
                    players = data.players || {};
                    obstacles = data.obstacles || [];
                    currentLevel = data.level || currentLevel;
                    currentScore = data.score || currentScore;
                    updateUI(); // Update score/level display
                } else if (data.type === 'yourId') {
                    myPlayerId = data.id;
                    currentLevel = data.currentLevel || 1; // Initial level from server
                    currentScore = data.currentScore || 0; // Initial score from server
                    console.log(`Received my Player ID: ${myPlayerId}`);
                    updateUI();
                } else if (data.type === 'playerLeft') {
                     // Optional: could remove player immediately from local cache
                     // delete players[data.id];
                     // updatePlayerList(); // Update UI immediately
                     console.log(`Player ${data.id} left.`);
                 }
                // Add other message types if needed (e.g., chat, specific events)

            } catch (error) {
                console.error('Error processing message:', event.data, error);
            }
        };

        ws.onerror = (error) => {
            console.error('WebSocket Error:', error);
            alert('Connection error. Please refresh.');
            usernamePrompt.style.display = 'flex'; // Show prompt again
            uiOverlay.style.display = 'none';
             canvas.style.display = 'none';
        };

        ws.onclose = () => {
            console.log('WebSocket connection closed.');
            alert('Connection closed. Please refresh.');
            ws = null; // Clear reference
            // Reset UI
            usernamePrompt.style.display = 'flex';
            uiOverlay.style.display = 'none';
            canvas.style.display = 'none';
            players = {};
            obstacles = [];
            myPlayerId = null;
        };
    }

    // --- Input Handling ---
     document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        keys[e.code.toLowerCase()] = true; // Store code too (like 'space')
        isMouseActive = false; // Keyboard overrides mouse flag
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
        keys[e.code.toLowerCase()] = false;
        isMouseActive = false; // Keyboard overrides mouse flag
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
        isMouseActive = true; // Mouse movement overrides keyboard flag
    });

     canvas.addEventListener('mouseleave', () => {
        // Optional: Stop sending mouse input if mouse leaves canvas?
        // Or just let the last position be the target
        // isMouseActive = false; // Or maybe not? Depends on desired behaviour
    });

    // --- Send Input to Server ---
    function sendInput() {
        if (!ws || ws.readyState !== WebSocket.OPEN || myPlayerId === null) {
            return;
        }

        const inputData = { type: 'input' };

        if (isMouseActive) {
            inputData.mouse = { x: mousePos.x, y: mousePos.y };
        } else {
             // Send only relevant keys to reduce data size
            const activeKeys = {};
            for (const key in keys) {
                if (keys[key]) {
                     activeKeys[key] = true;
                 }
            }
            inputData.keys = activeKeys;
        }

         // Simple rate limiting (already handled by setInterval, but good practice)
         const now = Date.now();
         if (now - lastSentInputTime > inputSendInterval * 0.8) { // Allow slight variation
            ws.send(JSON.stringify(inputData));
            lastSentInputTime = now;
        }
    }


    // --- Drawing Functions ---
    function drawPlayer(player) {
        ctx.fillStyle = player.color || 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;

        if (!player.isAlive) {
            ctx.globalAlpha = 0.4; // Make dead players semi-transparent
            ctx.fillStyle = '#AAAAAA'; // Grey out dead players
        } else {
             ctx.globalAlpha = 1.0;
        }

        // Draw player circle
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size || 15, 0, Math.PI * 2);
        ctx.fill();

        // Add outline if it's the local player
        if (player.id === myPlayerId) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        } else {
             ctx.stroke(); // Default black outline for others
        }


        // Draw username
        ctx.fillStyle = player.isAlive ? 'white' : '#ddd'; // Lighter grey for dead username
        ctx.font = '12px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText(player.username || `Player ${player.id}`, player.x, player.y - (player.size || 15) - 5);

        ctx.globalAlpha = 1.0; // Reset alpha
        ctx.textAlign = 'left'; // Reset text align
    }

    function drawObstacle(obstacle) {
        ctx.fillStyle = obstacle.color || '#ff4444';
        ctx.beginPath();
        ctx.arc(obstacle.x, obstacle.y, obstacle.size / 2, 0, Math.PI * 2);
        ctx.fill();
    }

    // --- Update UI ---
    function updateUI() {
        if (scoreDisplay) scoreDisplay.textContent = `Score: ${currentScore}`;
        if (levelDisplay) levelDisplay.textContent = `Level: ${currentLevel}`;
        updatePlayerList();
    }

    function updatePlayerList() {
         if (!playerListUl) return;
         playerListUl.innerHTML = ''; // Clear existing list
         Object.values(players).forEach(player => {
             const li = document.createElement('li');
             li.style.color = player.color || 'white';
             li.textContent = player.username || `Player ${player.id}`;
             if (!player.isAlive) {
                 li.classList.add('dead-player');
             }
             if (player.id === myPlayerId) {
                 li.textContent += ' (You)';
                 li.style.fontWeight = 'bold';
             }
             playerListUl.appendChild(li);
         });
     }


    // --- Game Loop (Client-side Rendering) ---
    function gameLoop() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
             console.log("WebSocket not open, stopping render loop.");
             return; // Stop loop if connection closes
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw obstacles
        obstacles.forEach(drawObstacle);

        // Draw players
        Object.values(players).forEach(drawPlayer);

        // Request next frame
        requestAnimationFrame(gameLoop);
    }

    // --- Initialization ---
     playBtn.addEventListener('click', () => {
         const username = usernameInput.value.trim();
         if (username) {
             connectWebSocket(username);
         } else {
             // Optional: Use a default or prompt again
             connectWebSocket(`Player${Math.floor(Math.random()*1000)}`); // Example default
         }
     });

     // Allow Enter key in username input
     usernameInput.addEventListener('keypress', (e) => {
         if (e.key === 'Enter') {
             playBtn.click(); // Trigger the button click
         }
     });

    // Initial UI setup
    resizeCanvas();
    canvas.style.display = 'none'; // Hide canvas initially
    uiOverlay.style.display = 'none'; // Hide game UI initially
    usernamePrompt.style.display = 'flex'; // Show username prompt
    usernameInput.focus();


})(); // End IIFE
</script>
</body>
</html>
